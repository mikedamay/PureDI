<?xml version="1.0" encoding="utf-8"?>
<topic id="IOCC-Profiles" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para>Profiles provide a means for the library user to select which classes to inject
      at run-time</para>
    </introduction>

    <section address="Section1">
      <title>Profiles</title>
      <content>
        <para>
          The essential purpose of dependency injection is to
          allow classes to be used by some class in the program
          to be swapped out without need to recode the calling
          class in any way.
        </para>

        <para>
          With the PDependencyInjector we accomplish that by
          allowing a profile string to be associated with any
          bean (class to be instantiated) by including
          the string as a parameter to the <codeInline>[Bean]</codeInline> attribute.
          The injector can
          be set up with a matching profile to ensure a
          matching set of beans are instantiated.
        </para>

        <para>
          The archetypal case is for testing which
          is particularly pertinent for the PDependencyInjector
          with its emphasis on injection into private
          member variables - other ways of handling mocks might fail here.
        </para>
        <para>
          The following example shows how mock functionality
          can be injected:
        </para>
        <code>
using System;
using PureDI;
using Microsoft.VisualStudio.TestTools.UnitTesting;

public class Profiles
{
    public static void Main()
    {
        PDependencyInjector pdi = new PDependencyInjector();
        MyService ms = pdi.CreateAndInjectDependencies&lt;MyService>().rootBean;
        Console.WriteLine(ms.DoStuff());   // prints "doing the real thing"
    }
}
[Bean]
public class MyService
{
    [BeanReference] private IMyRepository myRepository = null;
    public string DoStuff()
    {
        return myRepository.DoSomething();
    }
}
public interface IMyRepository
{
    string DoSomething();
}
[Bean]
public class MyRepository : IMyRepository
{
    public string DoSomething()
    {
        return "doing the real thing";
    }
}
[Bean(Profile = "test")]
public class MyTestRepository : IMyRepository
{
    public string DoSomething()
    {
        return "this is just a test";
    }
}
[TestClass]
public class SomeTest
{
    [TestMethod]
    public void ShouldPrintThisIsJustATest() =>
        Assert.AreEqual("this is just a test"
            , new PDependencyInjector(Profiles: new[] { "test" }).CreateAndInjectDependencies&lt;MyService>().rootBean.DoStuff()
        );
}
        </code>
        <para>
          The *myRepository bean* is referenced through an interface (*IMyRepository*)
          that the bean's class implements.
          Base classes can perform the same role as interfaces provided that they
          are not themselves marked as beans.
        </para>
        <para>
          There are two implementations of the interface:
          MyRepository which is the "production" implementation and *MyTestRepository*
          available for testing purposes.
        </para>
        <para>
          The main program does not pass a profile when it creates the *PDependencyInjector*.
          Therefore the production version of IMyRepository is instantiated.
          However the unit test passes a profile of "test" which matches the profile
          for *MyTestRepository* and allows the repository to be mocked when testing *MyService*.
        </para>
        <para>
          Notes:
        </para>
        <list class="bullet">
          <listItem>
            <para>
              <codeInline>CreateAndInjectDependencies</codeInline> will select a bean with a matching profile or, in the
              absence of a matching bean, a bean with no profile.
            </para>
          </listItem>
          <listItem>
            <para>
              It is possible (and, in fact, usual) to specify multiple profiles to the
              <codeInline>PDependencyInjector</codeInline> constructor.  This enables fine grained control at run-time
              of which implementations are to be used
            </para>
          </listItem>
        </list>
      </content>
    </section>

    <relatedTopics>
      <link xlink:href="IOCC-BeanNames">html Bean Names</link>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
