<?xml version="1.0" encoding="utf-8"?>
<topic id="DI-LimitationsAndGotchas" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para>Below is a list of limitations of the library and library behaviour that may
      catch out the unsuspecting user</para>
    </introduction>


    <section address="Remarks">
      <title>Remarks</title>
      <content>
      </content>
      <sections>
        <section address="Limitations">
          <title>Limitations</title>
          <content>
            <list class="ordered">
              <listItem>
                <para>
                  <legacyBold>Static Model: </legacyBold>The object model is fairly static.  Injections of singletons are associated with
                  an injection state.  PureDI's reference to the injections is determined by
                  the lifetime of a particular injection state object.
                  </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Static Objects do not participate and cannot be included
                  in any way in the injection mechanism</legacyBold>
                </para>
              </listItem>
              <listItem>
                <para>
                  <codeInline>readonly</codeInline> properties cannot have their value set by injection.  A constructor
                  or field must be involved.
                  By contrast readonly <legacyItalic>fields</legacyItalic> can be the target of injections.
                </para>
              </listItem>
              <listItem>
                <para>There is no way to inject through a variadic constructor</para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Bean Names vs. Profiles: </legacyBold> is not possible to combine alternative implementations with parallel implementations.
                  Suppose we have an <codeInline>IRepository</codeInline> interface
                  and two concrete classes that implement it say
                  <codeInline>LocalRepository</codeInline>
                  and <codeInline>RemoteRepository</codeInline>.
                  We cannot meet a requirement where a) in
                  production some classes need the <legacyItalic>LocalRepository</legacyItalic>
                  (say for configuration settings) and
                  some classes the <legacyItalic>RemoteRepository</legacyItalic>
                  (for general use) and b) on the developer machine
                  both repositories should be <legacyItalic>LocalRepository</legacyItalic>.
                  In the first case we need the remote
                  repository to have a bean <legacyBold>name</legacyBold>, say "remote" and
                  in the second case a <legacyBold>profile</legacyBold>, say "dev",
                  but no <legacyBold>name</legacyBold>.
                </para>
                <para>
                  One workaround is to have four versions of the repository
                  each having an unique combination of name and profile.  This
                  might be achieved with some thin "wrapper" derived classes.
                  Alternatively the use of factories and factory parameters
                  could be considered.
                </para>
              </listItem>
            </list>
          </content>
        </section>

        <section address="Gotchas">
          <title>Gotchas</title>
          <content>

            <list class="ordered">
              <listItem>
                <para>
                  <legacyBold>Exceptions Not Thrown: </legacyBold>Generally speaking where anomalies and inconsistencies are found
                  in the code subject to injection such as dangling bean references
                  no exception is thrown.  It is left to the library user to 
                  inspect the diagnostics returned in the injection state.
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Dangling Beans: </legacyBold>If a member is incorrectly marked as <codeInline>[BeanReference]</codeInline> then
                  it will be set to its default value even if it is an initialized member.
                </para>
                <para>A warning will be reported in the diagnostics</para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Factories: </legacyBold>Factories must both have a <codeInline>[bean]</codeInline> attribute
                  and implement <codeInline>IFactory</codeInline>.  If a factory
                  has only one of these then this will be recorded in diagnostics (<codeInline>Diagnostics</codeInline>)
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Missing Beans: </legacyBold>A risk, particularly with multiple entry points, is that the library user will forget
                  to include required assemblies in the "assemblies" argument when the injector is first created.
                  As a consequence "missing bean" type errors will occur,
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Duplicate Beans: </legacyBold>If a number of beans implement some widely used interface such as <codeInline>IEnumerable of T</codeInline>
                  and that interface is used in the declaration of member variables which
                  are bean references then
                  each implementing class involved will require bean names so that the injector can
                  select the appropriate bean for a given injection with the widely used type
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Factory Names: </legacyBold>For factories, the bean name (if present) refers to the selection of the factory.
                  It does not relate in any way to the class which is instantiated by the factory
                </para>
              </listItem>
              <listItem>
                <para>As you would expect beans have not been injected at the points when the class's constructor is called</para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Avoid Consructor Processing: </legacyBold>Avoid any processing of substance in beans' constructors.  There is a risk of inadvertently
                  accessing beans that have not been subject to injection.
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>There is no magic.</legacyBold>  You cannot simply stick a bean reference on some bean
                  and expect injection to take place.  It must be in the graph produced by
                  <codeInline>CreateAndInjectDependencies</codeInline>.  You mix
                  calls to <codeInline>new</codeInline> and <codeInline>CreateAndInjectDependencies</codeInline>
                  at your own risk.
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyBold>Missing Root Bean: </legacyBold>If you specify the root bean of the object tree with an interface, make sure
                  that either that interface is declared in the main assembly scanned for injection
                  or that the assembly is passed as a parameter to the
                  <codeInline>PDependencyInjector</codeInline>'s constructor.
                </para>
              </listItem>
            </list>
          </content>
        </section>

      </sections>
    </section>

    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
