<?xml version="1.0" encoding="utf-8"?>
<topic id="IOCC-LimitationsAndGotchas" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>

      <para>Below is a list of limitations of the library and library behaviour that may
      catch out the unsuspecting user</para>
    </introduction>


    <section address="LimitationsAndGotchas">
      <title>Details</title>
      <content>
        <para>Limitations</para>

        <list class="ordered">
          <listItem>
            <para>
              The object model is static - although new objects can be added at program entry points
              there is no facility to remove anything.  This will be addressed in the case of
              request and session scope objects for web applications in a future version.  In
              the mean time where this is necessary beans will have to be created with Prototype scope
            </para>
          </listItem>
          <listItem>
            <para>static classes and members are not handled</para>
          </listItem>
          <listItem>
            <para>
              <codeInline>readonly</codeInline> properties cannot have their value set by injection.  A constructor
              or field must be involved.
              is called.
            </para>
          </listItem>
          <listItem>
            <para>Variadic constructors are not supported</para>
          </listItem>
          <listItem>
            <para>
              It is not possible to combine alternative implementations with parallel implementations.
              Suppose we have an IRepository interface and two concrete classes that implement it say
              ILocalRepository and IRemoteRepository.  We cannot fulfill a requirement where a) in
              production some classes need the LocalRepository (say for configuration settings) and
              some classes the RemoteRepository (for general use) and b) on the developer machine
              both repositories should be LocalRepository.  In the first case we need the remote
              repository to have a bean <legacyBold>name</legacyBold>, say "remote" and
              in the second case a <legacyBold>profile</legacyBold>
              but no <legacyBold>name</legacyBold>.
            </para>
          </listItem>
        </list>

        <para>Gotchas</para>

        <list class="ordered">
          <listItem>
            <para>
              If a member is incorrectly marked as [IOCCBeanReference] then
              it will be set to its default value even if it is an initialized member
            </para>
          </listItem>
          <listItem>
            <para>
              Factories must both have a `[bean]` attribute and implement <codeInline>IFactory</codeInline>.  If a factory
              has only one of these then this will be recorded in diagnostics (`IOCCDiagnostics`)
            </para>
          </listItem>
          <listItem>
            <para>
              A risk, particularly with multiple entry points, is that the coder will forget
              to include required assemblies when the injector is created
            </para>
          </listItem>
          <listItem>
            <para>
              If a number of beans implement some widely used interface such as <codeInline>IEnumerable of T</codeInline> then
              each implementing class involved will require bean names so that the injector can
              select the appropriate bean for a given injection with the widely used type
            </para>
          </listItem>
          <listItem>
            <para>
              For factories the bean name (if present) refers to the selection of the factory.
              It does not relate in any way to the class which is instantiated by the factory
            </para>
          </listItem>
          <listItem>
            <para><codeInline>CreateAndInjectDependencies()</codeInline> is not thread safe</para>
          </listItem>
          <listItem>
            <para>As you would expect beans have not been injected when the class's constructor</para>
          </listItem>
          <listItem>
            <para>
              Avoid processing in beans' constructors.  There is a risk of inadvertently
              accessing beans that have not been subject to injection.
            </para>
          </listItem>
          <listItem>
            <para>
              There is no magic.  You cannot simply stick a bean reference on some bean
              and expect injection to take place.  It must be in the graph produced by
              <codeInline>CreateAndInjectDependencies</codeInline>.
            </para>
          </listItem>
          <listItem>
            <para>
              If you specify the root bean of the object tree with an interface, make sure
              that either that interface is declared in the main assembly subject to injection
              or that the assembly is passed as a parameter to the mechanism's constructor.
            </para>
          </listItem>
        </list>

      </content>
    </section>

    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
