<?xml version="1.0" encoding="utf-8"?>
<topic id="IOCC-Assemblies" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para>Dependency Injection is crucially dependent on a knowledge of assemblies
      that are or are expected to be loaded.  
      This section discusses the this aspect of the injection mechanism
      and what it means for the library user.</para>
    </introduction>

    <section address="Remarks">
      <title>Remarks</title>
      <content>
        <para>
          The injection mechanism works by examining the metadata of assemblies
          to discover candidate types for injection and then using reflection
          to instantiate beans (objects) and assign them to (inject them into) the member variables of
          containing beans or constructor parameters of containing beans.
        </para>
        <para>
          In order to accomplish this the library user must provide the injection
          mechanism with the identities of the assemblies that are subject to
          injection.  These can be passed to the <codeInline>PDependencyInjector</codeInline>
          constructor as follows: 
          <codeInline>var pdi = new PDependencyInjector(Assemblies: new[] {typeof(SomeTypeFromMyAssembly).Assembly});</codeInline>.
          Note that the constructor takes an array of references to assemblies
          rather than the names.  Not only is this is safer but it's actually more
          convenient for the library user once they get the hang of it.
        </para>
        <para>
          You will rarely see assemblies being passed to the constructor in the
          sample code in this user guide.  This is because the assembly of the
          root bean is automatically scanned for injection by default.  If the root
          type's assembly is the only one for which injection is required then the
          constructor can be called without the <codeInline>Assemblies</codeInline> parameter.
          <codeInline>var pdi = new PDependencyInjector();</codeInline>.
        </para>
        <para>
          One other assembly, besides the root type's, is included by default.  It
          is that of the PDependencyInjector itself, i.e. <legacyItalic>PureDI</legacyItalic>.  This is to allow
          beans such as bean factories to get access to the injector (by including a 
          <codeInline>[BeanReference]</codeInline> to the PDependencyInjector in
          the factory itself.
        </para>
        <para>
          All assemblies must be loaded before <codeInline>PDependencyInjector</codeInline>
          is instantiated.  The mechanism does not currently handle assemblies loaded
          at some later point, say some service provider loaded at a subsequent entry point.
        </para>
      </content>
        <sections>
          <section address="Note">
            <title>Note:</title>
            <content>
              <list class="bullet">
                <listItem>
                  <para>
                    There is no point in including an assembly for scanning that does not contain beans.
                  </para>
                </listItem>
                <listItem>
                  <para>
                    There may be edge cases where the library user needs to exclude the default assemblies
                    from scanning.  This can be achieved by passing one or two AssemblyExclusionFlags
                    to the constructor: <codeInline>AssemblyExclusion.ExcludeSimpleIOCContainer</codeInline> to
                    prevent the PDependencyInjector library itself from being scanned and <codeInline>
                      AssemblyExclusion.ExcludeRootTypeAssembly
                    </codeInline> to exclude the root type's assembly. e.g. <lineBreak/><codeInline>
                      var sic =
                      new PDependencyInjector(Assemblies: new[] {typeof(ClassDerivedFromRootType).Assembly},
                      ExcludeAssemblies: AssemblyExclusion.ExcludeSimpleIOCContainer |
                      AssemblyExclusion.ExcludeRootTypeAssembly);
                    </codeInline><lineBreak/> will scan only the ClassDerivedFromRootType's assembly. Bear in mind
                    that the root type passed to <codeInline>CreateAndInjectDependencies</codeInline> can
                    be an interface or base class of ClassDerivedFromRootType.
                  </para>
                </listItem>
              </list>
            </content>
          </section>
        </sections>
    </section>

    <relatedTopics>
      <link xlink:href="IOCC-LimitationsAndGotchas">Limitations &amp; Gotchas</link>
      <codeEntityReference>M:PureDI.PDependencyInjector.#ctor(System.String[],System.Reflection.Assembly[],PureDI.PDependencyInjector.AssemblyExclusion)</codeEntityReference>
      <codeEntityReference>T:PureDI.PDependencyInjector.AssemblyExclusion</codeEntityReference>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
