<?xml version="1.0" encoding="utf-8"?>
<topic id="DI-Assemblies" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para>Dependency Injection is crucially dependent on a knowledge of assemblies
      that are or are expected to be loaded.  
      This section discusses the this aspect of the injection mechanism
      and what it means for the library user.</para>
    </introduction>

    <section address="Remarks">
      <title>Remarks</title>
      <content>
        <para>
          The injection mechanism works by examining the metadata of assemblies
          to discover candidate types for injection and then using reflection
          to instantiate beans (objects) and assign them to (inject them into) the member variables of
          containing beans or constructor parameters of containing beans.
        </para>
        <para>
          In order to accomplish this the library user must provide the injection
          mechanism with the identities of the assemblies that are subject to
          injection.  These can be passed to the <codeInline>PDependencyInjector</codeInline>
          constructor as follows: 
          <codeInline>var pdi = new PDependencyInjector(Assemblies: new Assembly[]
          {typeof(SomeTypeFromMyAssembly).Assembly});</codeInline>.
          Note that the constructor takes an array of references to assemblies
          rather than the names.  Not only is this is safer but it's actually more
          convenient for the library user once they get the hang of it.
        </para>
        <para>
          You will rarely see assemblies being passed to the constructor in the
          sample code in this user guide.  This is because the assembly of the
          root bean is automatically scanned for injection by default.  If the root
          type's assembly is the only one for which injection is required then the
          constructor can be called without the <codeInline>Assemblies</codeInline> parameter.
          <codeInline>var pdi = new PDependencyInjector();
          var result = pdi.CreateAndInjectDependencies&lt;SomeRootClass>();</codeInline>.
        </para>
        <para>
          One other assembly, besides the root type's, is included by default.  It
          is that of the PDependencyInjector itself, i.e. <legacyItalic>PureDI</legacyItalic>.  This is to allow
          beans such as bean factories to get access to the injector (by including a 
          <codeInline>[BeanReference]</codeInline> to the PDependencyInjector in
          the factory itself.
        </para>
        <para>
          All assemblies must be loaded before a related call to  <codeInline>
          CreateAndInjectDependencies</codeInline>
          is made.  The injection mechanism does not load referenced assemblies itself.
        </para>
      </content>
        <sections>
          <section address="Note">
            <title>Note:</title>
            <content>
              <list class="bullet">
                <listItem>
                  <para>
                    There is no point in including an assembly for scanning that does not contain beans.
                  </para>
                </listItem>
                <listItem>
                  <para>
                    There may be occasions, for example, when running unit tests on the library source
                    where it 
                  </para>
                </listItem>
              </list>
            </content>
          </section>
        </sections>
    </section>

    <relatedTopics>
      <link xlink:href="DI-LimitationsAndGotchas">Limitations &amp; Gotchas</link>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
