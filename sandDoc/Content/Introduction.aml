<?xml version="1.0" encoding="utf-8"?>
<topic id="DI-Introduction" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para>
        PureDI is a
        C# library providing Dependency Injection (DI).  The framework and its approach to DI favour
        simplicity, transparency and verifiability over sophistication and comprehensiveness.
      </para>
      <para>
        The library is fully functional (feature complete with thorough testing).
        It needs hardening in the real world.
      </para>
    </introduction>

    <section address="Remarks">
      <title>Remarks</title>
      <content/>
      <sections>
        <section address="Setup">
          <title>Setup</title>
          <content>
            <para>The library is available from nuget.org with the following command:</para>
            <para>
              from the command line do:
            </para>
            <para>
              <command>
                nuget install PureDI-version 0.1.2-alpha
              </command>
            </para>
            <para>
              From the Visual Studio Package Manager console do:
            </para>
            <para>
              <command>
                install-package PureDI-version 0.1.2-alpha
              </command>
            </para>
            <para>
              Source code is available at
              <externalLink>
                <linkText>https://github.com/mikedamay/PureDI.git</linkText>
                <linkUri>https://github.com/mikedamay/PureDI.git</linkUri>
              </externalLink>
            </para>
            <para>
              This documentation is located at
              <externalLink>
                <linkText>http://mikedamay.co.uk/PureDI</linkText>
                <linkUri>http://mikedamay.co.uk/PureDI</linkUri>
              </externalLink>
            </para>
          </content>
        </section>
        <section address="Usage">
          <title>Usage</title>
          <content>
            <para>
              Usage follows the following pattern: the caller instantiates some significant object
              with a call to <codeInline>PDependencyInjector.CreateAndInjectDependencies</codeInline> and that
              object is created together with dependencies to which it refers
              and so forth recursively through the tree of dependencies.  The root of the
              tree is returned and the caller invokes methods on that.
            </para>
            <para>
              The call to <codeInline>CreateAndInjectDependencies</codeInline> is typically made at program
              startup.  The framework is principally concerned with singletons that
              have the same life span as the program.
            </para>
            <para>
              Dependent classes are identified with the <codeInline>[Bean]</codeInline>
              attribute and the corresponding member variables which refer to them with 
              <codeInline>[BeanReference]</codeInline> attributes.
            </para>
            <para>
              It is often inappropriate or impossible to create all objects at program startup 
              so similar injections can be made at subsequent entry 
              points (e.g. in a web application at web requests
              or interactive GUI on UI events).  These entry points will be able to create their own
              tree of objects which they can mix with previously created ones. This can
              be a useful mechanism in controlling the lifetime of the multiple sets of objects independently.
            </para>
            <para>The following illustrates simple usage:</para>
            <code>
using PureDI;
[Bean]
public class Program
{
    [BeanReference] private Logger logger = null;
    public static void Main()
    {
        PDependencyInjector pdi = new PDependencyInjector();
        Program prog = pdi.CreateAndInjectDependencies&lt;Program>().rootBean;
        prog.SaySomething();
    }
    private void SaySomething()
    {
        logger.Log("Hello Simple");
    }
}
[Bean]
public class Logger
{
    public void Log(string message) => System.Console.WriteLine(message);
}
            </code>
            <para>
              In the above example the <legacyItalic>Program</legacyItalic> class is
              instantiated in the call to <legacyItalic>CreateAndInjectDependencies</legacyItalic>
              which also creates an instance of <legacyItalic>Logger</legacyItalic> (because it is annotated with
              a <legacyItalic>BeanReferenceAttribute</legacyItalic>) and assigns it
              to the <legacyItalic>logger</legacyItalic> member variable.  Assignment to
              the member variable follows execution of <legacyItalic>Pragram&apos;s</legacyItalic>
              constructor, as you would expect.
            </para>
          </content>
        </section>
        <section address="Notes">
          <title>Notes</title>
          <content>
          <list class="bullet">
            <listItem>
              <para>
                Classes to be injected are annotated with the <codeInline>[Bean]</codeInline> attribute.
              </para>
            </listItem>
            <listItem>
              <para>
                Classes where a bean is to be injected (i.e. classes which refer to a bean) must themselves be marked as beans
              </para>
            </listItem>
            <listItem>
              <para>
                The site of the injection is annotated with a <codeInline>[BeanReference]</codeInline> attribute
              </para>
            </listItem>
            <listItem>
              <para>
                The type of a member variable where a bean is to be injected
                should be an interface, a direct or indirect base class of the bean.
              </para>
            </listItem>
            <listItem>
              <para>
                Once <codeInline>CreateAndInjectDependencies</codeInline> has been called all beans will have
                been instantiated and assigned to any matching bean references.  Typically, calls
                will only be made to the injector, subsequently, if the program has other
                entry points
              </para>
            </listItem>
            <listItem>
              <para>
                If a call is made to <codeInline>CreateAndInjectDependencies</codeInline>
                in respect of a type that has already been instantiated then
                a reference to that object is returned, a new object 
                is not created and no other processing is performed.  This enforces the
                singleton pattern.
              </para>
            </listItem>
          </list>
      </content>

        </section> 
      </sections>
    </section>

    <relatedTopics>
      <link xlink:href="DI-Assemblies">Assemblies</link>
      <link xlink:href="DI-LimitationsAndGotchas">Limitations &amp; Gotchas</link>
      <link xlink:href="DI-DesignRationale">Design Rationale</link>
      <link xlink:href="DI-Profiles">Profiles</link>
 
      <codeEntityReference>T:PureDI.PDependencyInjector</codeEntityReference>
      <codeEntityReference>M:PureDI.PDependencyInjector.CreateAndInjectDependencies``1(PureDI.InjectionState,PureDI.AssemblySpec,PureDI.RootBeanSpec)</codeEntityReference>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
