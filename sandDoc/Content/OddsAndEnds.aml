<?xml version="1.0" encoding="utf-8"?>
<topic id="IOCC-OddsAndEnds" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <para></para>
    </introduction>

    <section address="OddsAndEnd">
      <title></title>
      <content>
        <para>Object Cycles</para>

        <para>
          Problems may arise where objects directly or indirectly refer to themselves.
          In the case of member variables this kind of cyclical reference is allowed.
          In the case of constructor parameters an exception is thrown if
          an attempt is made to inject an object into the constructor of a declaring object
          of the same type.  This is for the obvious reason that infinite recursion would result.
        </para>

        <para>Ignore Interface (<codeInline>[IOCCIgnore]</codeInline>)</para>

        <para>
          The IOCCIgnore attribute can be annotated to any interface or class.  It addresses
          the case where some interface is implemented by multiple bean classes but is not used
          as a bean reference.  It will cause the container not to report the multiple implementations
          as duplicates.  It would be applied to some user-inspired equivalent of IComparable or
          ISerializable.
        </para>

        <para>Attribute Base Classes</para>

        <para>
          The <codeInline>[Bean]</codeInline>, <codeInline>[BeanReference]</codeInline>,
         <codeInline>[Constructor]</codeInline> and <codeInline>[IOCCIgnore]</codeInline> attributes
          are sealed classes.  In each case there is an equivalent base class #
          from which user defined classes can be derived.  This might be useful
          if there was a requirement for some complex factory with a number of parameters
          that could be named.
        </para>

        <para>The following:</para>

<code>
  [BeanReference(Factory=typeof(EnvironmentVariableFetcher), FactoryParam="MyEnvVar")]
  private string _someEnvVar;
</code>


  <para>would look much more approachable as:</para>

  <code>
    [EnvironmentVariable(VariableName: "MyEnvVar)]
    private string _someEnvVar;
  </code>

  <para>This can be achieved with:</para>

<code>
  public class EnvironementVariableAttribute : BeanReferenceBaseAttribute
  {
  public EnvironementVariableAttribute(string VariableName )
  {
  base.Factory = typeof(EnvironmentVariableFetcher);
  base.FactoryParam = VariableName;
  }
  }
</code>

      </content>
    </section>

    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
