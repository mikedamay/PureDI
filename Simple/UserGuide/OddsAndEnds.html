<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />    <title>Some Title</title>
    <link type="text/png" rel="icon" href="/glyphicons_free/glyphicons/png/glyphicons-30-notes-2.png" />
    <link type="text/css" href="/Simple/Content/bootstrap-3.3.7/css/bootstrap.css" rel="stylesheet"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="col-sm-1"></div>
        <div class="col-sm-10">
            <h3 class="col-sm-10" style="color: blue">Odds &amp; Ends</h3>
            <!--<hr class="col-xs-12"/>-->
        </div>
        <div class="col-sm-1"></div>
    </div>
    <div class="row">
        <div class="col-sm-1"></div>
        <div class="col-sm-10">
            <h3>Object Cycles</h3>
<p>Problems may arise where objects directly or indirectly refer to themselves.
In the case of member variables this kind of cyclical reference is allowed.
In the case of constructor parameters an exception is thrown if
an attempt is made to inject an object into the constructor of a declaring object
of the same type.  This is for the obvious reason that infinite recursion would result.</p>
<h3><code>[IOCCIgnore]</code></h3>
<p>The IOCCIgnore attribute can be annotated to any interface or class.  It addresses
the case where some interface is implemented by multiple bean classes but is not used
as a bean reference.  It will cause the container not to report the multiple implementations
as duplicates.  It would be applied to sone user-inspired equivalent of IComparable or
ISerializable.</p>
<h3>Attribute Base Classes</h3>
<p>The <code>[Bean]</code>, <code>[BeanReference]</code>, <code>[Constructor]</code> and <code>[IOCCIgnore]</code> attributes
are sealed classes.  In each case there is an equivalent base class #
from which user defined classes can be derived.  This might be useful
if there was a requirement for some complex factoory with a number of parameters
that could be named.</p>
<p>The following:</p>
<pre><code>[BeanReference(Factory=typeof(EnvironmentVariableFetcher), FactoryParam=&quot;MyEnvVar&quot;)]
private string _someEnvVar;
</code></pre>
<p>would look much more approachable as:</p>
<pre><code>[EnvironmentVariable(VariableName: &quot;MyEnvVar)]
private string _someEnvVar;
</code></pre>
<p>This can be achieved with:</p>
<pre><code>public class EnvironementVariableAttribute : BeanReferenceBaseAttribute
{
  public EnvironementVariableAttribute(string VariableName )
  {
    base.Factory = typeof(EnvironmentVariableFetcher);
    base.FactoryParam = VariableName;
  }
}

</code></pre>

        </div>
        <div class="col-sm-1"></div>
    </div>
</div>
</body>
</html>