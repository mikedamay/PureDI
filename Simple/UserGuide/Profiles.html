<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />    
    <title>Some Title</title>
    <link type="text/png" rel="icon" href="/glyphicons_free/glyphicons/png/glyphicons-30-notes-2.png" />
    <link type="text/css" href="/Simple/Content/bootstrap-3.3.7/css/bootstrap.css" rel="stylesheet"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="col-sm-1"></div>
        <div class="col-sm-10">
            <h3 class="col-sm-10" style="color: blue">Profiles</h3>
            <!--<hr class="col-xs-12"/>-->
        </div>
        <div class="col-sm-1"></div>
    </div>
    <div class="row">
        <div class="col-sm-1"></div>
        <div class="col-sm-10">
            <p>The essential purpose of dependency injection is to
allow classes to be used by some class in the program
to be swapped out without need to recode the calling
class in any way.</p>
<p>With the SimpleIOCContainer we accomplish that by
allowing a profile string to be associated with any
bean (class to be instantiated) by including
the string as a parameter to the <em>[Bean]</em> attribute.
The container can
be set up with a matching profile to ensure a
matching set of beans are instantiated.</p>
<p>The archetypical case is for testing which
is particularly pertinent for the SimpleIOCContainer
with its emphasis on injection into private
member variables.</p>
<p>The following example shows how mock functionality
can be injected:</p>
<div class="pre-scrollable">
<pre><code>using System;
using com.TheDisappointedProgrammer.IOCC;
using Microsoft.VisualStudio.TestTools.UnitTesting;

public class Profiles
{
    public static void Main()
    {
        SimpleIOCContainer sic = new SimpleIOCContainer();
        MyService ms = sic.CreateAndInjectDependenciesSimple&lt;MyService&gt;();
        Console.WriteLine(ms.DoStuff());   // prints &quot;doing the real thing&quot;
    }
}
[Bean]
public class MyService
{
    [BeanReference] private IMyRepository myRepository = null;
    public string DoStuff()
    {
        return myRepository.DoSomething();
    }
}
public interface IMyRepository
{
    string DoSomething();
}
[Bean]
public class MyRepository : IMyRepository
{
    public string DoSomething()
    {
        return &quot;doing the real thing&quot;;
    }
}
[Bean(Profile = &quot;test&quot;)]
public class MyTestRepository : IMyRepository
{
    public string DoSomething()
    {
        return &quot;this is just a test&quot;;
    }
}
[TestClass]
public class SomeTest
{
    [TestMethod]
    public void ShouldPrintThisIsJustATest() =&gt;
        Assert.AreEqual(&quot;this is just a test&quot;
            , new SimpleIOCContainer(Profiles: new[] { &quot;test&quot; }).CreateAndInjectDependenciesSimple&lt;MyService&gt;().DoStuff()
        );
}


</code></pre>
</div>
<p>Note:</p>
<ul>
<li>The <em>myRepository bean</em> is referenced through an interface (<em>IMyRepository</em>)
that the bean's class implements.
Base classes can perform the same role as interfaces provided that they
are not themselves marked as beans.</li>
<li>There are two implementations of the interface:
MyRepository which is the &quot;production&quot; implementation and <em>MyTestRepository</em>
available for testing purposes.</li>
<li>The main program does not pass a profile when it creates the <em>SimpleIOCContainer</em>.
Therefore the production version of IMyRepository is instantiated.
Howver the unit test passes a profile of &quot;test&quot; which matches the profile
for <em>MyTestRepository</em> and allows the repository to be mocked when testing <em>MyService</em>.</li>
<li><em>CreateAndInjectDependencies</em> will select a bean with a matching profile or, in the
absence of a matching bean, a bean with no profile.</li>
<li>It is possible (and, in fact, usual) to specify multiple profiles to the
<em>SimpleIOCContainer</em> constructor.  This enables fine grained control at run-time
of which implementations are to be used.</li>
</ul>
<p>See Also:</p>
<p><a href="/Simple/DiagnosticSchema/BeanNames.html">Bean Names (or one interface - two implementations)</a></p>

        </div>
        <div class="col-sm-1"></div>
    </div>
</div>
</body>
</html>