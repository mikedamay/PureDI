<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />    <title>Some Title</title>
    <link type="text/png" rel="icon" href="/glyphicons_free/glyphicons/png/glyphicons-30-notes-2.png" />
    <link type="text/css" href="/Simple/Content/bootstrap.css" rel="stylesheet"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="col-sm-1"></div>
        <div class="col-sm-10">
            <h3 class="col-sm-10" style="color: blue">Bean Factories</h3>
            <!--<hr class="col-xs-12"/>-->
        </div>
        <div class="col-sm-1"></div>
    </div>
    <div class="row">
        <div class="col-sm-1"></div>
        <div class="col-sm-10">
            <p>In some situations there is no straightforward way for the container
to know how to create a required bean.  For instance a repository might need
to be connected to its database before it can be injected.</p>
<p>This problem is overcome with the use of bean factories.</p>
<p>A factory is specified as a parameter to the BeanReference attribute.
So instead of creating some implementation of the member variable
type, the container calls the execute method of the factory which
creates and provides an object of the appropriate type.</p>
<p>A factory parameter (<code>FactoryParameter</code>) specified on the bean reference
can optionally be passed to the factory's execute method.</p>
<p>The following code provides a simple example.</p>
<div class="pre-scrollable">
<pre><code>using System;
using com.TheDisappointedProgrammer.IOCC;

[Bean]
public class FactoryUser
{
    [BeanReference(Factory = typeof(EnvironmentVariableFactory))]
      private IRepository2 repo = null;
    public static void Main()
    {
        var factoryUser = new SimpleIOCContainer().CreateAndInjectDependencies&lt;FactoryUser&gt;();
        Console.WriteLine(factoryUser.repo.GetData());
                // will print null unless you happen to have an environment
                // variable called CONNECTION_STRING
    }
}
[Bean]
public class EnvironmentVariableFactory : IFactory
{
    public object Execute(BeanFactoryArgs args)
    {
        return new Repository(Environment.GetEnvironmentVariable(&quot;CONNECTION_STRING&quot;));
    }
}

public class Repository : IRepository2
{
    private readonly string _connectionString;
    public Repository(string connectionString)
    {
        _connectionString = connectionString;
    }

    public string GetData()
    {
        return _connectionString;
    }
}

public interface IRepository2
{
    string GetData();
}



</code></pre>
</div>
<p>Note:</p>
<ul>
<li>Classes over which the library user has no control can
be injected using factories.  This can include strings, ints etc.</li>
<li>Factories must be marked with the <code>[Bean]</code> attribute</li>
<li>Factories must implement the <code>IFactory</code> interface</li>
<li>Many use cases not covered by other mechanisms can be
addressed with the use of bean factories.</li>
</ul>

        </div>
        <div class="col-sm-1"></div>
    </div>
</div>
</body>
</html>